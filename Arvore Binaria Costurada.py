# -*- coding: utf-8 -*-
"""Copy of BST_Costura.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vRz51CpB7CujKyhcD4fyCG4lzBj6xTaW
"""

class TreeNode:
    def __init__(self, left=None, right=None, value=None, Lt=None, Rt=None):
        self.left     = left
        self.right    = right
        self.data     = value
        self.Lthread  = Lt
        self.Rthread  = Rt

class Tree:
    def __init__(self):
        self.root = None
        self.header = TreeNode(None,self.root,None,0,1)
        self.header.left = self.header
        self.nodes = 0
        

    def addNode(self, node, value):
        if(self.root == None):
            self.root = TreeNode(self.header,self.header,value,1,1)
            
        else:
            if(value == node.data):
                print("Valor existente")
                
            if(value<node.data):
                
                if(node.Lthread == 1):
                    new_node = TreeNode(node.left,node,value,1,1)
                    node.left = new_node
                    node.Lthread = 0
                    self.nodes += 1
                    
                else:
                    self.addNode(node.left, value);
            else:
                
                if(node.Rthread == 1):
                    new_node = TreeNode(node,node.right,value,1,1)
                    node.right = new_node
                    node.Rthread = 0
                    self.nodes += 1
                    
                else:
                    self.addNode(node.right, value)

    
    def search(self, node, value):
        if(value == node.data or node == None):
            return node
        else:
          if(value<node.data):
            return self.search(node.left, value)
          else:
            return self.search(node.right, value)
            
    def next_node(self,pt1):
        pt2 = pt1.right
        if (pt1.Rthread == 0):
            while(pt2.Lthread == 0):
                pt2 = pt2.left
        return pt2
        
    def prev_node(self,pt1):    
        pt2 = pt1.left
        if (pt1.Lthread == 0):
            while(pt2.Rthread == 0):
                pt2 = pt2.right
        return pt2
                
    def delNode(self, node, value):
        #caso a arvore esteja vazia
        if(self.root == None):
            print("Empty tree")
            
        else:
            #caso o valor esteja na raiz e a raiz seja o unico elemento da arvore
            if (self.root.data == value and (self.root.right == self.root.left) ):
                 self.root = None
                    
            else:
                find = self.search(node, value)
                if (find == None):
                    print("Valor nao encontrado")
                    
                else:
                    #procura o predecessor
                    if (find.left):
                        temp = self.prev_node(find)
                    
                        #caso nao possua filhos
                        if (temp.Lthread == temp.Rthread):
                            temp.left.Rthread = 1
                            temp.left.right = find
                            find.data = temp.data
                            temp = None
                        else:
                            self.prev_node(temp).right = temp.right
                            find.data = temp.data
                            #remover temp
                            temp = temp.left
                            
                            
                         
                    else:
                        #nao existe predecessor
                        #procura o sucessor
                        temp = self.next_node(find)
                        
                        #caso nao possua filhos
                        if (temp.Lthread == temp.Rthread):
                            temp.right.Lthread = 1
                            temp.right.left = find
                            find.data = temp.data
                            temp = None
                        else:
                            self.next_node(temp).left = temp.left
                            find.data = temp.data
                            #remover temp
                            temp = temp.right
                        
                
    def in_order(self, node):
        aux = node
        while (aux.Lthread != 1) :
            aux = aux.left
        
        stack = []
        
        while (len(stack) <= self.nodes):
            
            if(aux.Lthread == 0 and aux.left.data not in stack ):
                aux = aux.left
            else:
                stack.append(aux.data)
                aux = aux.right
        print(stack)

def do_the_magic():
    teste = Tree()
    teste.addNode(teste.root, 100)
    teste.addNode(teste.root, 50)
    teste.addNode(teste.root, 150)
    teste.addNode(teste.root, 250)
    teste.addNode(teste.root, 200)
    return teste

teste = do_the_magic()

teste.in_order(teste.root)

hold = teste.prev_node(teste.root)

print(hold.data)

find = teste.search(teste.root,150)

find.data

teste.delNode(teste.root,50)

teste.in_order(teste.root)